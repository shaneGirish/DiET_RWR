package diet.client;

import java.awt.event.KeyEvent;
import java.util.Date;
import java.util.Vector;

import diet.task.mazegame.ClientMazeGameComms;
import diet.attribval.AttribVal;
import diet.client.ClientInterfaceEvents.ClientInterfaceEvent;
import diet.client.ClientInterfaceEvents.ClientInterfaceEventTracker;
import diet.client.ConnectionToServer;
import diet.client.JChatFrame;
import diet.client.JChatFrameMultipleWindowsWithSendButtonWidthByHeight;
import diet.message.Keypress;
import java.awt.Color;

/**
 * This is the intermediary between low-level exchange of messages between
 * client and server (handled by ConnectionToServer) and higher-level UI events
 * handled by the JChatFrame chat window.
 * <p>
 * It handles both events generated by the chat window and also commands
 * received from the server
 * 
 * <p>
 * Some of the methods are associated with particular user interfaces. In
 * particular, the methods pre-fixed with WYSIWYG are associated with the
 * "what you see is what you get" / character-by-character interfaces.
 * 
 * @author user
 */
public class ClientEventHandler {

	private JChatFrame jcf;
	private ConnectionToServer cts;
	/**
	 * This records for each turn all keypresses. It is reset whenever the
	 * participant presses Enter/Return/Send
	 */
	private Vector keyspressedSinceLastTextEntry = new Vector();
	private Vector clientEventsSinceLastTextEntry = new Vector();

	long startOfTyping = new Date().getTime(); // If they start typing before
												// the interface is fully set
												// up, this value is used as the
												// start time
	boolean startOfTypingHasBeenRecorded = false;
	public boolean participantIsEnteringControlCode;
	// public boolean currentTurnBeingConstructedHasBeenBlocked = false;

	public ClientInterfaceEventTracker ciet = new ClientInterfaceEventTracker(this);

	// private ClientSetupParameters
	public ClientEventHandler() {
		super();

	}

	/**
	 * Associates this with ConnectionToServer which deals with low-level
	 * exchange of messages
	 * 
	 * @param cts
	 */
	public void setConnectionToServer(ConnectionToServer cts) {
		this.cts = cts;
	}

	/**
	 * Associates this with a Chat window interface
	 * 
	 * @param jcf
	 */
	public void setChatFrame(JChatFrame jcf) {
		this.jcf = jcf;

	}

	public JChatFrame getChatFrame() {
		return jcf;
	}

	/**
	 * Appends text to the participant's chat window. Text usually contains
	 * 
	 * @param s
	 * @param windowNumber
	 */
	public void appendWithCaretCheck(String msgFROMSERVERID, String prefix, boolean showPrefix, String text,
			int windowNumber, Object style) {
		String s = "";
		String t = "";
		// if(prefix==null)System.exit(-5);
		if (prefix != null)
			s = s + prefix;
		if (text != null)
			t = t + text;
		jcf.appendWithCaretCheck(msgFROMSERVERID, s + ": ", showPrefix, t, windowNumber, style);

	}

	/**
	 * Don't need to press a send button if participants press ENTER
	 */
	public void sendButtonPressedDEPRECATED() {

		/*
		 * String[] priorChatText = {"","",""}; String text =
		 * jcf.getTextEnteredInField(); text = text.replaceAll("\n", ""); if(jcf
		 * instanceof JChatFrameMultipleWindowsWithSendButtonWidthByHeight){
		 * jcf.appendWithCaretCheck("", cts.getUsername()+ ": ", true, text,
		 * jcf.getParticipantsOwnWindow(), "SELF");
		 * 
		 * }
		 * 
		 * cts.sendChatText(text, startOfTyping, false,
		 * keyspressedSinceLastTextEntry,priorChatText);
		 * 
		 * jcf.clearTextEntryField(true);
		 * clearKeypressesAndClientEventsAfterSend();
		 * 
		 */

	}

	/**
	 * Retrieves text from chat window's text-entry field, does preliminary
	 * removal of white space, appends it to the local client's chat window,
	 * sends the text to {@link ConnectionToServer} in order to be sent to the
	 * server, clears the local timing / and keypress information associated
	 * with the turn and then clears the text-entry field.
	 */
	public void returnPressed() {
		// System.out.println("return pressed");

		// System.err.println("THE CONTENTS ARE:"+jcf.getContentsOfWindow(0));
		// System.err.println("---------------------------");

		// String[] priorChatText = {"","",""} ;

		String text = jcf.getTextEnteredInField();
		text = text.replaceAll("\\p{Cntrl}", "");
		if (jcf instanceof JChatFrameMultipleWindowsWithSendButtonWidthByHeight) {
			jcf.appendWithCaretCheck("", cts.getUsername() + ": ", true, text, jcf.getParticipantsOwnWindow(), "SELF");
		}

		cts.sendChatText((text), startOfTyping, false, keyspressedSinceLastTextEntry,
				this.clientEventsSinceLastTextEntry);

		jcf.clearTextEntryField(true);
		clearKeypressesAndClientEventsAfterSend();

	}

	/**
	 * Clears the information stored for the turn being constructed
	 */
	public void clearKeypressesAndClientEventsAfterSend() {
		startOfTypingHasBeenRecorded = false;
		startOfTyping = -400000;
		keyspressedSinceLastTextEntry.removeAllElements();
		keyspressedSinceLastTextEntry = new Vector();

		this.clientEventsSinceLastTextEntry.removeAllElements();
		this.clientEventsSinceLastTextEntry = new Vector();
	}

	/**
	 * Processes each keypress associated with the chat tool window. In the
	 * current implementation, any key pressed while pressing and holding down
	 * the "Ctrl key" is treated as not being associated with turn-construction
	 * and is instead relayed to the TaskController (e.g ClientMazeGameComms if
	 * it exists).
	 *
	 * @param e
	 */
	public void keyPressFilter(KeyEvent e) {

		try {
			if (cts.cteh != null && cts.cteh instanceof ClientMazeGameComms) {
				((ClientMazeGameComms) cts.cteh).relayKeypressToMazeFrame(e);
			}

			int i = e.getKeyCode();
			if (i == 17) {
				this.participantIsEnteringControlCode = true;
				this.jcf.setEditable(false);

			}
			if (this.participantIsEnteringControlCode) {
				if (i == 37 || i == 38 || i == 39 || i == 40) {

				}
			} else if (!participantIsEnteringControlCode) {
				if (!startOfTypingHasBeenRecorded) {
					startOfTypingHasBeenRecorded = true;
					startOfTyping = new Date().getTime();
				}

				Keypress kp = new Keypress(i, new Date().getTime());
				keyspressedSinceLastTextEntry.addElement(kp);

				cts.sendClientIsTyping(kp, this.jcf.getTextEnteredInField().replaceAll("\\p{Cntrl}", ""));
				// cts.sendClientIsTyping(kp, ".....");
			}
		} catch (Exception e2) {
			cts.sendErrorMessage(e2);
		}

	}

	/**
	 * Detects whether the key being released is the "Ctrl" key. If yes, the
	 * control sequence being relayed to the TaskController (e.g.
	 * ClientMazeGameComms) is terminated.
	 * 
	 * @param e
	 */
	public void keyReleaseFilter(KeyEvent e) {
		try {
			if (cts.cteh != null && cts.cteh instanceof ClientMazeGameComms) {
				((ClientMazeGameComms) cts.cteh).relayKeyReleaseFilterToMazeFrame(e);
			}

			if (e.getKeyCode() == 17) {
				participantIsEnteringControlCode = false;
				this.jcf.setEditable(true);
				// System.out.println("go"+e.getKeyCode());

			}
			if (e.getKeyCode() == 10) {
				//// returnPressed(); ///this is no longer called from this
				//// method.Instead it is called from the Document of the
				//// chatframe
			}
		} catch (Exception e2) {
			cts.sendErrorMessage(e2);
		}
	}

	/**
	 * Adds String to the WYSIWYG chat window at the specified position
	 * 
	 * @param windowNumber
	 * @param replacementText
	 * @param offset
	 * @param length
	 */
	public void wYSIWYGUpdateDocumentInsert(int windowNumber, String replacementText, int offset, int length) {
		jcf.wYSIWYGUpdateDocumentInsert(windowNumber, replacementText, offset, length);
	}

	/**
	 * Removes text from the chat window at the specified position/length
	 * 
	 * @param windowNumber
	 * @param offset
	 * @param length
	 */
	public void wYSIWYGUpdateDocumentRemove(int windowNumber, int offset, int length) {
		jcf.wYSIWYGUpdateDocumentRemove(windowNumber, offset, length);
	}

	public void wYSIWYGDocumentHasChanged(String textAtEndOfString, int offset) {
		try {
			// System.out.println("WYSIWYGCLEVENTHANDLER1");
			String[] priorChatText = { "", "", "" };
			cts.sendChatTextWYSIWYG(textAtEndOfString, offset, priorChatText);
			// System.out.println("WYSIWYGIN CLEVENTHANDLER2");
		} catch (Exception e) {
			// EMUI.println(cts.getUsername(),"ERROR IN CLEVENTHANDLER");
		}
		// clearKeypresses();
	}

	/**
	 * Invoked by the WYSIWYG interface when text is deleted at the specified
	 * offset/length
	 * 
	 * @param offset
	 * @param length
	 */
	public void wYSIWYGDocumentHasChangedRemove(int offset, int length, String textInTextEntryWindow) {
		try {
			String[] priorChatText = { "", "", "" };
			cts.sendWYSIWYGDocumentHasChangedRemove(offset, length, textInTextEntryWindow, priorChatText);
			// System.out.println("WYSIWYGIN CLEVENTHANDLER2");
		} catch (Exception e) {
			cts.sendErrorMessage(e);
		}
	}

	/**
	 * Invoked by the WYSIWYG interface when text is inserted at the specified
	 * offset/length
	 * 
	 * @param text
	 * @param offset
	 * @param length
	 */
	public void textEntryDocumentHasChangedInsert(String text, int offset, int length, String textInTextEntryWindow) {
		try {
			String[] priorChatText = { "", "", "" };
			cts.sendWYSIWYGDocumentHasChangedInsert(text, offset, length, textInTextEntryWindow, priorChatText);
			// System.out.println("WYSIWYGIN CLEVENTHANDLER2");
		} catch (Exception e) {
			cts.sendErrorMessage(e);
		}
	}

	/**
	 * Changes the position of the cursor and the selected text in the WYSIWYG
	 * chat window
	 * 
	 * @param windowNumber
	 * @param startPos
	 * @param finishPos
	 */
	public void wWYSIWYGChangeCursorAndSelectionInWindow(int windowNumber, int startPos, int finishPos) {
		jcf.wYSIWYGChangeCursorAndSelection(windowNumber, startPos, finishPos);
		// System.out.println("RECEIVING SELECTION "+startPos+" "+finishPos);
	}

	public ConnectionToServer getCts() {
		return this.cts;
	}

	public void changeInterfaceProperties(String uniqueIDGeneratedByServer, int newInterfaceproperties, Object value,
			Object value2) {

		if (newInterfaceproperties == (ClientInterfaceEventTracker.changeMazeWindow)) {
			try {
				((ClientMazeGameComms) this.cts.cteh).displayMessageInWindow((String) value, (Long) value2);
			} catch (Exception e) {
				e.printStackTrace();
			}
			return;
		}
		if (newInterfaceproperties == (ClientInterfaceEventTracker.changeBorderOfMazeFrame)) {
			ClientMazeGameComms cmgc = (ClientMazeGameComms) this.cts.cteh;
			cmgc.changeBorderOfMazeFrame((int) value, (Color) value2);
		}

		jcf.changeInterfaceProperties(uniqueIDGeneratedByServer, newInterfaceproperties, value, value2);
		// System.exit(-444445);
	}

	/**
	 * Closes down the client, freeing resources
	 */
	public void closeDown() {
		try {
			jcf.setVisible(false);
			jcf.closeDown();
			jcf.dispose();
			this.jcf = null;
			cts = null;
			System.err.println("ClientEventHandler closing down");
		} catch (Exception e) {

		}
		System.exit(-111222);
		System.err.println("CLOSING DOWN THE CLIENT");
	}

	public void reportInterfaceEvent(String type, long clienttimeofdisplay, AttribVal... values) {

		ClientInterfaceEvent ce = this.ciet.addClientEvent(type, clienttimeofdisplay, values);
		this.clientEventsSinceLastTextEntry.add(ce);
	}

}
