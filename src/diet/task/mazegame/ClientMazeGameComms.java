/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package diet.task.mazegame;

/**
 *
 * @author user
 */
import diet.attribval.AttribVal;
import diet.client.ClientInterfaceEvents.ClientInterfaceEventTracker;
import java.awt.Dimension;
import java.awt.event.KeyEvent;
import java.util.Date;

import javax.swing.SwingUtilities;

import diet.client.ConnectionToServer;
import diet.debug.Debug;
import diet.message.MessageTask;
import diet.task.ClientTaskEventHandler;
import diet.task.mazegame.message.*;
import java.awt.Color;

/**
 * This deals with events generated by the maze game, local client keyboard
 * input and maze game messages received from the server.
 * <p>
 * It unpacks messages from the server and generates messages to be sent to the
 * server.
 * 
 *
 * @author user
 */
public class ClientMazeGameComms extends ClientTaskEventHandler {
	// private ConnectionToServer cts;
	// private Socket kkSocket = null;
	// ObjectOutputStream out = null;
	// ObjectInputStream in = null;
	JMazeFrame jmf;

	Game gam;// = new Game("Empty");
	String dispMessage = null;
	// String serverName;
	// int isDirector=0;//0 if dyadic.
	// 1 if triadic and client is director.
	// 2 if triadic and client is not director
	Date timeOfLastKeyPress = new Date();

	public ClientMazeGameComms(final ConnectionToServer cts, final MessageNewMazeGame mng) {
		super(cts);
		final ClientMazeGameComms cmgc = this;

		SwingUtilities.invokeLater(new Runnable() {
			public void run() {
				try {
					jmf = new JMazeFrame();
					System.err.println("HEREB2");
					jmf.setComms(cmgc);
					System.err.println("HEREB3");
					jmf.setVisible(true);
					System.err.println("HEREB4");
					processNewGameRequest(mng);
					System.err.println("HEREB5");
					// this.setDisplayMessage("Waiting for other computers to
					// connect....");

				} catch (Exception e) {
					System.err.println(e.getMessage().toString());
					System.out.println("STACKTRACE:");
					e.printStackTrace();
				}
			}

		});

	}

	public void changeBorderOfMazeFrame(final int pixelwidth, final Color colour) {
		try {
			SwingUtilities.invokeLater(new Runnable() {
				public void run() {
					jmf.jfgp.changeBorder(pixelwidth, colour);
					jmf.repaint();
					jmf.jPanel3.repaint();
				}
			});
		} catch (Exception e) {
			System.err.println("ERROR CHANGING BORDER " + e.getMessage().toString());
		}

	}

	public void repaintJMazeFrame(final String clientinterfaceventname, final boolean sendEventToServer) {
		try {
			SwingUtilities.invokeLater(new Runnable() {
				public void run() {
					long timeOfEvent = new Date().getTime();
					jmf.jPanel3.repaint();
					AttribVal av2 = new AttribVal("dummyattribval", "dummyvalue");
					if (sendEventToServer)
						cts.cEventHandler.reportInterfaceEvent(clientinterfaceventname, timeOfEvent, av2);

				}
			});
		} catch (Exception e) {
			System.err.println("ERROR REPAINTING MAZE " + e.getMessage().toString());
		}
	}

	/**
	 * Processes messages that arrive from the server. The types and contents of
	 * these messages are used to determine appropriate updates to the local
	 * maze game.
	 * 
	 * @param mt
	 */
	public void processTaskMove(MessageTask mt) {
		if (mt instanceof MessageChangeGateStatus) {
			final MessageChangeGateStatus mscgs = (MessageChangeGateStatus) mt;

			boolean gatesAreOpenInState0 = jmf.jPanel3.maz.gatesOpen;
			boolean gatesAreOpenInState1 = mscgs.gatesAreOpen();

			jmf.jPanel3.maz.gatesOpen = mscgs.gatesAreOpen();
			String eventtype = "";

			if (!gatesAreOpenInState0 & gatesAreOpenInState1)
				eventtype = ClientInterfaceEventTracker.mazegameOpenGates;
			if (gatesAreOpenInState0 & !gatesAreOpenInState1)
				eventtype = ClientInterfaceEventTracker.mazegameCloseGates;

			repaintJMazeFrame(eventtype, true);
			// this.setDisplayMessage(null);
		} else if (mt instanceof MessageNextMaze_SentAsIndex) {
			final MessageNextMaze_SentAsIndex mnm = (MessageNextMaze_SentAsIndex) mt;
			System.err.println("ATTEMPTING TO MOVE MAZE TO: " + mnm.getNext());
			SwingUtilities.invokeLater(new Runnable() {
				public void run() {
					processNextGameRequest(mnm.getNext(), mnm.getGame(), mnm.getDisplayText());
				}
			});

		} else if (mt instanceof MessageNextMaze_SentAsMaze) { // Dont use this
			// MessageNextMaze_SentAsMaze mnMaze =
			// (MessageNextMaze_SentAsMaze)mt;
			// System.err.println("ATTEMPTING TO MOVE MAZE TO: "+mnm.getNext());
			// processNextGameRequest(mnm.getNext());

		} else if (mt instanceof MessageStartGame) {
			MessageStartGame msg = (MessageStartGame) mt;
			this.setDisplayMessage(null);
			repaintJMazeFrame("", false);
		} else if (mt instanceof MessageWaitForOthersToCatchUp) {
			MessageWaitForOthersToCatchUp msg = (MessageWaitForOthersToCatchUp) mt;
			this.setDisplayMessage(msg.getText());
			repaintJMazeFrame("", false);
		}

	}

	/**
	 * Constructs a message containing the position of the marker within the
	 * maze game.
	 * 
	 * @param d2
	 */
	public void sendCursorPos(Dimension d2) {
		System.err.println("HERET - SENDCURSORPOS");
		int mazeGsmeNo = -1;
		try {

			try {
				mazeGsmeNo = gam.getAllMazes().indexOf(jmf.jPanel3.maz);
			} catch (Exception e) {
				e.printStackTrace();
			}
			MessageCursorUpdate mscu = new MessageCursorUpdate(cts.getEmail(), cts.getUsername(), d2, mazeGsmeNo);

			cts.sendMessage(mscu);

			// out.writeObject(mscu);
			// out.flush();
		} catch (Exception e) {
			System.out.println(e.getMessage());
		}

	}

	/**
	 * Receives keypresses typed locally by the client and relays them to the
	 * maze game. Initial filtering of keypresses is handled by @link
	 * ClientEventHandler.
	 * 
	 * @param e
	 */
	public void relayKeypressToMazeFrame(KeyEvent e) {
		System.err.println("HERET - RELAYING KEYPRESS TO MAZE FRAME");
		jmf.keyPressFilter(e);
	}

	/**
	 * Receives the keycodes of the keys typed locally by the client and relays
	 * them to the maze game. Initial filtering of keypresses is handled by
	 * {@link diet.client.ClientEventHandler}.
	 * 
	 * @param e
	 *            key pressed
	 */
	public void relayKeyReleaseFilterToMazeFrame(KeyEvent e) {
		jmf.keyReleaseFilter(e);
		System.err.println("HERET - RELAYING KEYRELEASE TO MAZE FRAME");
	}

	/**
	 * Returns the String currently being displayed in the Maze Game window
	 * (distinct from the JChatFrame)
	 * 
	 * @return message displayed in the maze game window
	 */
	public String getDisplayMessage() {
		return this.dispMessage;
	}

	/**
	 * Displays the String in the Maze Game window
	 * 
	 * @param msg
	 */
	public void setDisplayMessage(String msg) {
		dispMessage = msg;
		jmf.jPanel3.paint(jmf.jPanel3.getGraphics());

	}

	/**
	 * Retrieves list of mazes from message sent by server and initializes the
	 * maze game to the first maze.
	 * 
	 * @param msng
	 */
	private void processNewGameRequest(MessageNewMazeGame msng) {
		System.err.println("HEREC1");
		gam = msng.getGame();
		System.err.println("HEREC2");
		// gam.clientName = cts.getUsername();
		System.err.println("HEREC3");
		jmf.jPanel3.maz = gam.getMazeNo(0);
		System.err.println("HEREC4");
		jmf.jPanel3.resetCursorToBegin();
		System.err.println("HEREC5");
		jmf.jPanel3.paint(jmf.jPanel3.getGraphics());
		System.err.println("HEREC6");
		jmf.jPanel3.resetCursorToBegin();
		System.err.println("HEREC7");

	}

	public void debugMoveCursorToGOAL() {
		jmf.jPanel3.maz.moveTo(new Dimension(jmf.jPanel3.maz.finish.x, jmf.jPanel3.maz.finish.y));
		jmf.cms.sendCursorPos(new Dimension(jmf.jPanel3.maz.current.x, jmf.jPanel3.maz.current.y));
	}

	public void displayMessageInWindow(String text, long lengthOfTime) {
		setDisplayMessage(text);
		repaintJMazeFrame("", false);
		try {
			if (lengthOfTime > 0)
				this.sleep(lengthOfTime);
		} catch (Exception e) {
		}
		if (lengthOfTime > 0)
			setDisplayMessage(null);
	}

	/**
	 * Called when all participants in maze game are on their respective goals.
	 * Selects and displays the next maze in the Vector of stored mazes
	 * 
	 * @param i
	 */
	private void processNextGameRequest(int i, Game g, String message) {
		try {
			if (g != null) {
				this.gam = g;
			}

			int maxGameNo = gam.getAllMazes().size();
			jmf.jPanel3.maz = (Maze) gam.getAllMazes().elementAt(i);// gam.nextMaze();
			jmf.jPanel3.resetCursorToBegin();
			setDisplayMessage(message);
			repaintJMazeFrame("", false);
			try {
				this.sleep(2000);
			} catch (Exception e) {
			}
			setDisplayMessage(null);
			jmf.jPanel3.resetCursorToBegin();
			jmf.jPanel3.maz.moveTo(new Dimension(0, 0));
			jmf.jPanel3.maz.changeGates(false);

			System.out.println("processing next game request");
			repaintJMazeFrame("", false);

		} catch (Exception e) {
			System.err.println("ERROR PROCESSING NEXT GAME REQUEST: " + i);
			e.printStackTrace();
		}
	}

	private void resetWaitingForNextExperiment() {
		setDisplayMessage("Experiment Finished.");
		try {
			this.sleep(1000);
		} catch (Exception e) {
		}

	}

	public void closeDown() {
		try {
			jmf.setVisible(false);
			jmf.dispose();
			jmf = null;
		} catch (Exception e) {
			System.err.println("Could not close down the maze properly: " + e.getMessage());
		}
	}

}
